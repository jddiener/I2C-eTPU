// This file is auto-generated by the ASH WARE ETEC Linker.
// It contains useful information for host-CPU side driver code
//    !!!   DO NOT EDIT THIS FILE   !!!
// Copyright (C) 2015 ASH WARE, Inc.

#ifndef __etpu_c_set_defines_H
#define __etpu_c_set_defines_H

// Register ECR, field ETB, byte address, Each Engine
// ECR.ETB = (C_ENTRY_TABLE_BASE_ADDR_)>>11;
#define C_ENTRY_TABLE_BASE_ADDR_                 0x00

// Starting DATA RAM address where the block copy of initialized data begins
// memcpy( ETPU_DATA_RAM_START+C_GLOBAL_INIT_DATA_ADDR_, &_global_mem_init[0], _GLOBAL_DATA_SIZE_);
#define C_GLOBAL_INIT_DATA_ADDR_                 0x00

// Register MISCCMPR - ETPU MISC Compare Register
// MISCCMPR = C_MISC_VALUE_;
#define C_MISC_VALUE_                            0xC988688E

// SCM Off Opcode - opcode returned when in the weeds
// SCMOFFDATAR = C_SCM_OFF_OPCODE_;
#define C_SCM_OFF_OPCODE_                        0xFFD08CC7

// exported autodef macros from user "#pragma export_autodef_macro" commands
// none specified

// exported autodef text from user "#pragma export_autodef_text" commands
// none specified

// 32-bit Global Variable address
// address = SPRAM + C_GLOB_VAR32__Global_error_data_
#define C_GLOB_VAR32__Global_error_data_         0x00
// defines for type enum I2C_SLAVE_MODE
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = C_GLOB_TAG_TYPE_SIZE_I2C_SLAVE_MODE_
#define C_GLOB_TAG_TYPE_SIZE_I2C_SLAVE_MODE_     0x01
// values of the literals of an enum type
// value = C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_FIND_IDLE_
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_FIND_IDLE_ 0x00
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_IDLE_ 0x01
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_START_SDA_LOW_ 0x02
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_WRITE_HEADER_ 0x03
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_WRITE_BYTE_ 0x04
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_WRITE_BYTE_CHECK_STOP_ 0x05
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_WRITE_BYTE_CHECK_STOP2_ 0x06
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_READ_BYTE_ 0x07
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_READ_FIND_STOP_ 0x08
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_READ_FIND_STOP2_ 0x09
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_ACK_OUT_ 0x0A
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_ACK_IN_ 0x0B
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_ACK_COMPLETE_ 0x0C
#define C_GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_IGNORE_ 0x0D

// Global Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define C_GLOB_VAR_TYPE__Global_error_data_      T_sint32

// Global Variable/Data Size (not including scratchpad)
// address (end) = SPRAM + C_GLOBAL_VAR_SIZE_
#define C_GLOBAL_VAR_SIZE_                       0x04

// Global Scratchpad Base Address in bytes
// address (start) = SPRAM + C_GLOBAL_SCRATCHPAD_BASE_ADDR_
#define C_GLOBAL_SCRATCHPAD_BASE_ADDR_           0x04

// Global Scratchpad Data Size in bytes
// address (end) = SPRAM + _GLOBAL_VAR_SIZE_ + C_GLOBAL_SCRATCHPAD_SIZE_
#define C_GLOBAL_SCRATCHPAD_SIZE_                0x00

// Total Global Data Size (starts at address 0, includes any global scratchpad allocation)
// address (end) = SPRAM + C_GLOBAL_DATA_SIZE_
#define C_GLOBAL_DATA_SIZE_                      0x04

// User Engine Variable/Data Size (not including scratchpad)
// address (end) = ((ECR_X.ERBA)<<9) + C_ENGINE_VAR_SIZE_
#define C_ENGINE_VAR_SIZE_                       0x00

// Engine Scratchpad Data Size in bytes
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_VAR_SIZE_ + C_ENGINE_SCRATCHPAD_SIZE_
#define C_ENGINE_SCRATCHPAD_SIZE_                0x00

// Total Engine Data Size (starts at engine address 0, includes any engine scratchpad allocation)
// address (end) = ((ECR_X.ERBA)<<9) + C_ENGINE_DATA_SIZE_
#define C_ENGINE_DATA_SIZE_                      0x00

// Amount of DATA RAM (in bytes) required for the stack
// (ideally, programs require none)
// #define CHANNEL_FRAME_START (((_GLOBAL_DATA_SIZE_ + C_STACK_SIZE_) + 7) & ~7)
#define C_STACK_SIZE_                            0x00

// Default channel frame base address definitions
// One for the single eTPU case, one for the dual eTPU case
#define C_CHANNEL_FRAME_1ETPU_BASE_ADDR  0x8
#define C_CHANNEL_FRAME_2ETPU_BASE_ADDR  0x8

#if 0
// This section gives an example of how stack bases should
// be initialized for each new channel frame (replace FUNC1, etc.
// with actual function names) in a simulator script file.  Host
// code should use the same mechanism.  The conditional initialization
// is done because a channel frame will not have a stack base allocated
// if it is not needed.
#ifdef _CPBA24_FUNC1___STACKBASE_
write_chan_data24(FUNC1_CHAN1, _CPBA24_FUNC1___STACKBASE_, C_ETPU_A_STACK_BASE_ADDR);
#endif // _CPBA24_FUNC1___STACKBASE_
#ifdef _CPBA24_FUNC2___STACKBASE_
write_chan_data24(FUNC2_CHAN1, _CPBA24_FUNC2___STACKBASE_, C_ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN2, _CPBA24_FUNC2___STACKBASE_, C_ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN3, _CPBA24_FUNC2___STACKBASE_, C_ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN4, _CPBA24_FUNC2___STACKBASE_, C_ETPU_B_STACK_BASE_ADDR);
#endif // _CPBA24_FUNC2___STACKBASE_
// continue on through all channels for both eTPUs...
#endif // 0

//============================================================================
//==========     I2C_slave

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = C_FUNCTION_NUM_I2C_slave_I2C_SCL_in_;
#define C_FUNCTION_NUM_I2C_slave_I2C_SCL_in_     0x04
#define C_FUNCTION_NUM_I2C_slave_I2C_SCL_out_    0x05
#define C_FUNCTION_NUM_I2C_slave_I2C_SDA_in_     0x06
#define C_FUNCTION_NUM_I2C_slave_I2C_SDA_out_    0x07

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = C_ENTRY_TABLE_TYPE_I2C_slave_I2C_SCL_in_;
#define C_ENTRY_TABLE_TYPE_I2C_slave_I2C_SCL_in_ 0x01
#define C_ENTRY_TABLE_TYPE_I2C_slave_I2C_SCL_out_ 0x00
#define C_ENTRY_TABLE_TYPE_I2C_slave_I2C_SDA_in_ 0x01
#define C_ENTRY_TABLE_TYPE_I2C_slave_I2C_SDA_out_ 0x00

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = C_ENTRY_TABLE_PIN_DIR_I2C_slave_I2C_SCL_in_;
#define C_ENTRY_TABLE_PIN_DIR_I2C_slave_I2C_SCL_in_ 0x00
#define C_ENTRY_TABLE_PIN_DIR_I2C_slave_I2C_SCL_out_ 0x00
#define C_ENTRY_TABLE_PIN_DIR_I2C_slave_I2C_SDA_in_ 0x00
#define C_ENTRY_TABLE_PIN_DIR_I2C_slave_I2C_SDA_out_ 0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + C_CPBA8_I2C_slave__address_
#define C_CPBA8_I2C_slave__address_              0x04
#define C_CPBA8_I2C_slave__address_mask_         0x08
#define C_CPBA8_I2C_slave__error_flags_          0x0C
#define C_CPBA8_I2C_slave__latched_error_flags_  0x10

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + C_CPBA24_I2C_slave__accept_general_call_
#define C_CPBA24_I2C_slave__accept_general_call_ 0x1D
#define C_CPBA24_I2C_slave__read_buffer_size_    0x21
#define C_CPBA24_I2C_slave__write_buffer_size_   0x25
#define C_CPBA24_I2C_slave__read_buffer_         0x29
#define C_CPBA24_I2C_slave__write_buffer_        0x2D
#define C_CPBA24_I2C_slave__tSU_DAT_             0x31
#define C_CPBA24_I2C_slave__tBUF_                0x35
#define C_CPBA24_I2C_slave__header_              0x39
#define C_CPBA24_I2C_slave__byte_cnt_            0x3D

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define C_CPBA_TYPE_I2C_slave__address_          T_uint8
#define C_CPBA_TYPE_I2C_slave__address_mask_     T_uint8
#define C_CPBA_TYPE_I2C_slave__accept_general_call_ T_uint24
#define C_CPBA_TYPE_I2C_slave__read_buffer_size_ T_uint24
#define C_CPBA_TYPE_I2C_slave__write_buffer_size_ T_uint24
#define C_CPBA_TYPE_I2C_slave__read_buffer_      T_ptr
#define C_CPBA_TYPE_PTR_I2C_slave__read_buffer_  T_uint8
#define C_CPBA_TYPE_I2C_slave__write_buffer_     T_ptr
#define C_CPBA_TYPE_PTR_I2C_slave__write_buffer_ T_uint8
#define C_CPBA_TYPE_I2C_slave__tSU_DAT_          T_uint24
#define C_CPBA_TYPE_I2C_slave__tBUF_             T_uint24
#define C_CPBA_TYPE_I2C_slave__header_           T_uint24
#define C_CPBA_TYPE_I2C_slave__byte_cnt_         T_uint24
#define C_CPBA_TYPE_I2C_slave__error_flags_      T_uint8
#define C_CPBA_TYPE_I2C_slave__latched_error_flags_ T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + C_FRAME_SIZE_I2C_slave_;
#define C_FRAME_SIZE_I2C_slave_                  0x40

//============================================================================
//==========     I2C_master

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = C_FUNCTION_NUM_I2C_master_I2C_SCL_out_;
#define C_FUNCTION_NUM_I2C_master_I2C_SCL_out_   0x00
#define C_FUNCTION_NUM_I2C_master_I2C_SCL_in_    0x01
#define C_FUNCTION_NUM_I2C_master_I2C_SDA_out_   0x02
#define C_FUNCTION_NUM_I2C_master_I2C_SDA_in_    0x03

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = C_ENTRY_TABLE_TYPE_I2C_master_I2C_SCL_out_;
#define C_ENTRY_TABLE_TYPE_I2C_master_I2C_SCL_out_ 0x01
#define C_ENTRY_TABLE_TYPE_I2C_master_I2C_SCL_in_ 0x01
#define C_ENTRY_TABLE_TYPE_I2C_master_I2C_SDA_out_ 0x00
#define C_ENTRY_TABLE_TYPE_I2C_master_I2C_SDA_in_ 0x00

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = C_ENTRY_TABLE_PIN_DIR_I2C_master_I2C_SCL_out_;
#define C_ENTRY_TABLE_PIN_DIR_I2C_master_I2C_SCL_out_ 0x00
#define C_ENTRY_TABLE_PIN_DIR_I2C_master_I2C_SCL_in_ 0x00
#define C_ENTRY_TABLE_PIN_DIR_I2C_master_I2C_SDA_out_ 0x00
#define C_ENTRY_TABLE_PIN_DIR_I2C_master_I2C_SDA_in_ 0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + C_CPBA8_I2C_master__cmd_cnt_
#define C_CPBA8_I2C_master__cmd_cnt_             0x0C
#define C_CPBA8_I2C_master__in_use_flag_         0x10
#define C_CPBA8_I2C_master__error_flags_         0x14
#define C_CPBA8_I2C_master__latched_error_flags_ 0x18

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + C_CPBA24_I2C_master__tLOW_
#define C_CPBA24_I2C_master__tLOW_               0x21
#define C_CPBA24_I2C_master__tHIGH_              0x25
#define C_CPBA24_I2C_master__tBUF_               0x29
#define C_CPBA24_I2C_master__tSU_STA_            0x2D
#define C_CPBA24_I2C_master__tSU_STO_            0x31
#define C_CPBA24_I2C_master__tHD_DAT_            0x35
#define C_CPBA24_I2C_master__tr_max_             0x39
#define C_CPBA24_I2C_master__p_cmd_list_         0x3D

// tag type info used by channel frame variables

// defines for type struct (typedef I2C_cmd)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = C_CHAN_TAG_TYPE_SIZE_I2C_cmd_
#define C_CHAN_TAG_TYPE_SIZE_I2C_cmd_            0x08
// raw size (padding not included) of a tag type
// value (raw size) = C_CHAN_TAG_TYPE_RAW_SIZE_I2C_cmd_
#define C_CHAN_TAG_TYPE_RAW_SIZE_I2C_cmd_        0x08
// alignment relative to a double even address of the tag type (address & 0x3)
// value = C_CHAN_TAG_TYPE_ALIGNMENT_I2C_cmd_
#define C_CHAN_TAG_TYPE_ALIGNMENT_I2C_cmd_       0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define C_CHAN_MEMBER_TYPE_I2C_master_I2C_cmd_header_ T_uint8
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + C_CHAN_MEMBER_BYTEOFFSET_I2C_master_I2C_cmd_header_
#define C_CHAN_MEMBER_BYTEOFFSET_I2C_master_I2C_cmd_header_ 0x00
#define C_CHAN_MEMBER_TYPE_I2C_master_I2C_cmd_p_buffer_ T_ptr
#define C_CHAN_MEMBER_BYTEOFFSET_I2C_master_I2C_cmd_p_buffer_ 0x01
#define C_CHAN_MEMBER_TYPE_I2C_master_I2C_cmd_size_ T_uint24
#define C_CHAN_MEMBER_BYTEOFFSET_I2C_master_I2C_cmd_size_ 0x05

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define C_CPBA_TYPE_I2C_master__tLOW_            T_uint24
#define C_CPBA_TYPE_I2C_master__tHIGH_           T_uint24
#define C_CPBA_TYPE_I2C_master__tBUF_            T_uint24
#define C_CPBA_TYPE_I2C_master__tSU_STA_         T_uint24
#define C_CPBA_TYPE_I2C_master__tSU_STO_         T_uint24
#define C_CPBA_TYPE_I2C_master__tHD_DAT_         T_uint24
#define C_CPBA_TYPE_I2C_master__tr_max_          T_uint24
#define C_CPBA_TYPE_I2C_master__p_cmd_list_      T_ptr
#define C_CPBA_TYPE_PTR_I2C_master__p_cmd_list_  T_struct
#define C_CPBA_TYPE_I2C_master__cmd_cnt_         T_uint8
#define C_CPBA_TYPE_I2C_master__in_use_flag_     T_uint8
#define C_CPBA_TYPE_I2C_master__error_flags_     T_uint8
#define C_CPBA_TYPE_I2C_master__latched_error_flags_ T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + C_FRAME_SIZE_I2C_master_;
#define C_FRAME_SIZE_I2C_master_                 0x40

#endif // __etpu_c_set_defines_H
