// This file is auto-generated by the ASH WARE ETEC Linker.
// It contains useful information for host-CPU side driver code
//    !!!   DO NOT EDIT THIS FILE   !!!
// Copyright (C) 2015 ASH WARE, Inc.

#ifndef __etpu_set_defines_H
#define __etpu_set_defines_H

// Register ECR, field ETB, byte address, Each Engine
// ECR.ETB = (_ENTRY_TABLE_BASE_ADDR_)>>11;
#define _ENTRY_TABLE_BASE_ADDR_                  0x00

// Starting DATA RAM address where the block copy of initialized data begins
// memcpy( ETPU_DATA_RAM_START+_GLOBAL_INIT_DATA_ADDR_, &_global_mem_init[0], _GLOBAL_DATA_SIZE_);
#define _GLOBAL_INIT_DATA_ADDR_                  0x00

// Register MISCCMPR - ETPU MISC Compare Register
// MISCCMPR = _MISC_VALUE_;
#define _MISC_VALUE_                             0xC988688E

// SCM Off Opcode - opcode returned when in the weeds
// SCMOFFDATAR = _SCM_OFF_OPCODE_;
#define _SCM_OFF_OPCODE_                         0xFFD08CC7

// exported autodef macros from user "#pragma export_autodef_macro" commands
// none specified

// exported autodef text from user "#pragma export_autodef_text" commands
// none specified

// 32-bit Global Variable address
// address = SPRAM + _GLOB_VAR32__Global_error_data_
#define _GLOB_VAR32__Global_error_data_          0x00
// defines for type enum I2C_SLAVE_MODE
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _GLOB_TAG_TYPE_SIZE_I2C_SLAVE_MODE_
#define _GLOB_TAG_TYPE_SIZE_I2C_SLAVE_MODE_      0x01
// values of the literals of an enum type
// value = _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_FIND_IDLE_
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_FIND_IDLE_ 0x00
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_IDLE_ 0x01
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_START_SDA_LOW_ 0x02
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_WRITE_HEADER_ 0x03
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_WRITE_BYTE_ 0x04
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_WRITE_BYTE_CHECK_STOP_ 0x05
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_WRITE_BYTE_CHECK_STOP2_ 0x06
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_READ_BYTE_ 0x07
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_READ_FIND_STOP_ 0x08
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_READ_FIND_STOP2_ 0x09
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_ACK_OUT_ 0x0A
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_ACK_IN_ 0x0B
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_ACK_COMPLETE_ 0x0C
#define _GLOB_ENUM_LITERAL_I2C_SLAVE_MODE_I2C_SLAVE_MODE_IGNORE_ 0x0D

// Global Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _GLOB_VAR_TYPE__Global_error_data_       T_sint32

// Global Variable/Data Size (not including scratchpad)
// address (end) = SPRAM + _GLOBAL_VAR_SIZE_
#define _GLOBAL_VAR_SIZE_                        0x04

// Global Scratchpad Base Address in bytes
// address (start) = SPRAM + _GLOBAL_SCRATCHPAD_BASE_ADDR_
#define _GLOBAL_SCRATCHPAD_BASE_ADDR_            0x04

// Global Scratchpad Data Size in bytes
// address (end) = SPRAM + _GLOBAL_VAR_SIZE_ + _GLOBAL_SCRATCHPAD_SIZE_
#define _GLOBAL_SCRATCHPAD_SIZE_                 0x00

// Total Global Data Size (starts at address 0, includes any global scratchpad allocation)
// address (end) = SPRAM + _GLOBAL_DATA_SIZE_
#define _GLOBAL_DATA_SIZE_                       0x04

// User Engine Variable/Data Size (not including scratchpad)
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_VAR_SIZE_
#define _ENGINE_VAR_SIZE_                        0x00

// Engine Scratchpad Data Size in bytes
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_VAR_SIZE_ + _ENGINE_SCRATCHPAD_SIZE_
#define _ENGINE_SCRATCHPAD_SIZE_                 0x00

// Total Engine Data Size (starts at engine address 0, includes any engine scratchpad allocation)
// address (end) = ((ECR_X.ERBA)<<9) + _ENGINE_DATA_SIZE_
#define _ENGINE_DATA_SIZE_                       0x00

// Amount of DATA RAM (in bytes) required for the stack
// (ideally, programs require none)
// #define CHANNEL_FRAME_START (((_GLOBAL_DATA_SIZE_ + _STACK_SIZE_) + 7) & ~7)
#define _STACK_SIZE_                             0x00

// Default channel frame base address definitions
// One for the single eTPU case, one for the dual eTPU case
#define _CHANNEL_FRAME_1ETPU_BASE_ADDR  0x8
#define _CHANNEL_FRAME_2ETPU_BASE_ADDR  0x8

#if 0
// This section gives an example of how stack bases should
// be initialized for each new channel frame (replace FUNC1, etc.
// with actual function names) in a simulator script file.  Host
// code should use the same mechanism.  The conditional initialization
// is done because a channel frame will not have a stack base allocated
// if it is not needed.
#ifdef _CPBA24_FUNC1___STACKBASE_
write_chan_data24(FUNC1_CHAN1, _CPBA24_FUNC1___STACKBASE_, _ETPU_A_STACK_BASE_ADDR);
#endif // _CPBA24_FUNC1___STACKBASE_
#ifdef _CPBA24_FUNC2___STACKBASE_
write_chan_data24(FUNC2_CHAN1, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN2, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN3, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
write_chan_data24(FUNC2_CHAN4, _CPBA24_FUNC2___STACKBASE_, _ETPU_B_STACK_BASE_ADDR);
#endif // _CPBA24_FUNC2___STACKBASE_
// continue on through all channels for both eTPUs...
#endif // 0

//============================================================================
//==========     I2C_slave

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_I2C_slave_I2C_SCL_in_;
#define _FUNCTION_NUM_I2C_slave_I2C_SCL_in_      0x04
#define _FUNCTION_NUM_I2C_slave_I2C_SCL_out_     0x05
#define _FUNCTION_NUM_I2C_slave_I2C_SDA_in_      0x06
#define _FUNCTION_NUM_I2C_slave_I2C_SDA_out_     0x07

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_I2C_slave_I2C_SCL_in_;
#define _ENTRY_TABLE_TYPE_I2C_slave_I2C_SCL_in_  0x01
#define _ENTRY_TABLE_TYPE_I2C_slave_I2C_SCL_out_ 0x00
#define _ENTRY_TABLE_TYPE_I2C_slave_I2C_SDA_in_  0x01
#define _ENTRY_TABLE_TYPE_I2C_slave_I2C_SDA_out_ 0x00

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = _ENTRY_TABLE_PIN_DIR_I2C_slave_I2C_SCL_in_;
#define _ENTRY_TABLE_PIN_DIR_I2C_slave_I2C_SCL_in_ 0x00
#define _ENTRY_TABLE_PIN_DIR_I2C_slave_I2C_SCL_out_ 0x00
#define _ENTRY_TABLE_PIN_DIR_I2C_slave_I2C_SDA_in_ 0x00
#define _ENTRY_TABLE_PIN_DIR_I2C_slave_I2C_SDA_out_ 0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_I2C_slave__address_
#define _CPBA8_I2C_slave__address_               0x04
#define _CPBA8_I2C_slave__address_mask_          0x08
#define _CPBA8_I2C_slave__error_flags_           0x0C
#define _CPBA8_I2C_slave__latched_error_flags_   0x10

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_I2C_slave__accept_general_call_
#define _CPBA24_I2C_slave__accept_general_call_  0x1D
#define _CPBA24_I2C_slave__read_buffer_size_     0x21
#define _CPBA24_I2C_slave__write_buffer_size_    0x25
#define _CPBA24_I2C_slave__read_buffer_          0x29
#define _CPBA24_I2C_slave__write_buffer_         0x2D
#define _CPBA24_I2C_slave__tSU_DAT_              0x31
#define _CPBA24_I2C_slave__tBUF_                 0x35
#define _CPBA24_I2C_slave__header_               0x39
#define _CPBA24_I2C_slave__byte_cnt_             0x3D

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_I2C_slave__address_           T_uint8
#define _CPBA_TYPE_I2C_slave__address_mask_      T_uint8
#define _CPBA_TYPE_I2C_slave__accept_general_call_ T_uint24
#define _CPBA_TYPE_I2C_slave__read_buffer_size_  T_uint24
#define _CPBA_TYPE_I2C_slave__write_buffer_size_ T_uint24
#define _CPBA_TYPE_I2C_slave__read_buffer_       T_ptr
#define _CPBA_TYPE_PTR_I2C_slave__read_buffer_   T_uint8
#define _CPBA_TYPE_I2C_slave__write_buffer_      T_ptr
#define _CPBA_TYPE_PTR_I2C_slave__write_buffer_  T_uint8
#define _CPBA_TYPE_I2C_slave__tSU_DAT_           T_uint24
#define _CPBA_TYPE_I2C_slave__tBUF_              T_uint24
#define _CPBA_TYPE_I2C_slave__header_            T_uint24
#define _CPBA_TYPE_I2C_slave__byte_cnt_          T_uint24
#define _CPBA_TYPE_I2C_slave__error_flags_       T_uint8
#define _CPBA_TYPE_I2C_slave__latched_error_flags_ T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_I2C_slave_;
#define _FRAME_SIZE_I2C_slave_                   0x40

//============================================================================
//==========     I2C_master

// Register CXCR, field CFS, Function Number, Each Channel
// CXCR.CFS = _FUNCTION_NUM_I2C_master_I2C_SCL_out_;
#define _FUNCTION_NUM_I2C_master_I2C_SCL_out_    0x00
#define _FUNCTION_NUM_I2C_master_I2C_SCL_in_     0x01
#define _FUNCTION_NUM_I2C_master_I2C_SDA_out_    0x02
#define _FUNCTION_NUM_I2C_master_I2C_SDA_in_     0x03

// Register CXCR, field ETCS, Type (Alternate or Standard), Each Channel
// CXCR.ETCS = _ENTRY_TABLE_TYPE_I2C_master_I2C_SCL_out_;
#define _ENTRY_TABLE_TYPE_I2C_master_I2C_SCL_out_ 0x01
#define _ENTRY_TABLE_TYPE_I2C_master_I2C_SCL_in_ 0x01
#define _ENTRY_TABLE_TYPE_I2C_master_I2C_SDA_out_ 0x00
#define _ENTRY_TABLE_TYPE_I2C_master_I2C_SDA_in_ 0x00

// Register CXCR, field ETPD, Pin Direction (Input or Output), Each Channel
// CXCR.ETPD = _ENTRY_TABLE_PIN_DIR_I2C_master_I2C_SCL_out_;
#define _ENTRY_TABLE_PIN_DIR_I2C_master_I2C_SCL_out_ 0x00
#define _ENTRY_TABLE_PIN_DIR_I2C_master_I2C_SCL_in_ 0x00
#define _ENTRY_TABLE_PIN_DIR_I2C_master_I2C_SDA_out_ 0x00
#define _ENTRY_TABLE_PIN_DIR_I2C_master_I2C_SDA_in_ 0x00

// 8-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA8_I2C_master__cmd_cnt_
#define _CPBA8_I2C_master__cmd_cnt_              0x0C
#define _CPBA8_I2C_master__in_use_flag_          0x10
#define _CPBA8_I2C_master__error_flags_          0x14
#define _CPBA8_I2C_master__latched_error_flags_  0x18

// 24-bit Channel Variable address offsets
// address = ((CXCR.CPBA)<<3) + _CPBA24_I2C_master__tLOW_
#define _CPBA24_I2C_master__tLOW_                0x21
#define _CPBA24_I2C_master__tHIGH_               0x25
#define _CPBA24_I2C_master__tBUF_                0x29
#define _CPBA24_I2C_master__tSU_STA_             0x2D
#define _CPBA24_I2C_master__tSU_STO_             0x31
#define _CPBA24_I2C_master__tHD_DAT_             0x35
#define _CPBA24_I2C_master__tr_max_              0x39
#define _CPBA24_I2C_master__p_cmd_list_          0x3D

// tag type info used by channel frame variables

// defines for type struct (typedef I2C_cmd)
// size of a tag type (including padding as defined by sizeof operator)
// value (sizeof) = _CHAN_TAG_TYPE_SIZE_I2C_cmd_
#define _CHAN_TAG_TYPE_SIZE_I2C_cmd_             0x08
// raw size (padding not included) of a tag type
// value (raw size) = _CHAN_TAG_TYPE_RAW_SIZE_I2C_cmd_
#define _CHAN_TAG_TYPE_RAW_SIZE_I2C_cmd_         0x08
// alignment relative to a double even address of the tag type (address & 0x3)
// value = _CHAN_TAG_TYPE_ALIGNMENT_I2C_cmd_
#define _CHAN_TAG_TYPE_ALIGNMENT_I2C_cmd_        0x00
// Channel tag type member type
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CHAN_MEMBER_TYPE_I2C_master_I2C_cmd_header_ T_uint8
// offset of struct/union members from variable base location
// the offset of bitfields is specified in bits, otherwise it is bytes
// address = ((CXCR.CPBA)<<3) + [variable CPBA offset] + _CHAN_MEMBER_BYTEOFFSET_I2C_master_I2C_cmd_header_
#define _CHAN_MEMBER_BYTEOFFSET_I2C_master_I2C_cmd_header_ 0x00
#define _CHAN_MEMBER_TYPE_I2C_master_I2C_cmd_p_buffer_ T_ptr
#define _CHAN_MEMBER_BYTEOFFSET_I2C_master_I2C_cmd_p_buffer_ 0x01
#define _CHAN_MEMBER_TYPE_I2C_master_I2C_cmd_size_ T_uint24
#define _CHAN_MEMBER_BYTEOFFSET_I2C_master_I2C_cmd_size_ 0x05

// Channel Variable type information
// Can be used in conjunction with other auto-define information to simplify interfaces
#define _CPBA_TYPE_I2C_master__tLOW_             T_uint24
#define _CPBA_TYPE_I2C_master__tHIGH_            T_uint24
#define _CPBA_TYPE_I2C_master__tBUF_             T_uint24
#define _CPBA_TYPE_I2C_master__tSU_STA_          T_uint24
#define _CPBA_TYPE_I2C_master__tSU_STO_          T_uint24
#define _CPBA_TYPE_I2C_master__tHD_DAT_          T_uint24
#define _CPBA_TYPE_I2C_master__tr_max_           T_uint24
#define _CPBA_TYPE_I2C_master__p_cmd_list_       T_ptr
#define _CPBA_TYPE_PTR_I2C_master__p_cmd_list_   T_struct
#define _CPBA_TYPE_I2C_master__cmd_cnt_          T_uint8
#define _CPBA_TYPE_I2C_master__in_use_flag_      T_uint8
#define _CPBA_TYPE_I2C_master__error_flags_      T_uint8
#define _CPBA_TYPE_I2C_master__latched_error_flags_ T_uint8

// Channel Frame Size, amount of RAM required for each channel
// CXCR.CPBA (this) = CXCR.CPBA (last) + _FRAME_SIZE_I2C_master_;
#define _FRAME_SIZE_I2C_master_                  0x40

#endif // __etpu_set_defines_H
